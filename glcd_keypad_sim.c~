#include <mega64a.h>
#include <glcd.h>
#include <font5x7.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // »—«Ì «” ›«œÂ «“  «»⁄ atoi
//#include <stdint.h>

typedef unsigned char uint8_t;
typedef unsigned int  uint16_t;
typedef signed char   int8_t;


#define glcd_pixel(x, y, color) glcd_setpixel(x, y)



// #define F_CPU 8000000UL
#include <delay.h>

// ---  ‰ŸÌ„«  «’·Ì ---
#define APN "mcinet" // APN «Å—« Ê— ŒÊœ —« Ê«—œ ò‰Ìœ
//#define SERVER_URL "http://google.com/api/authorize" // ¬œ—” ò«„· ”—Ê— ŒÊœ —« «Ì‰Ã« ﬁ—«— œÂÌœ
#define SERVER_URL_POST "http://193.5.44.191/home/post/"

#define HTTP_TIMEOUT_MS 500

#define read_flash_byte(p) (*(p))

// --- »«›—Â«Ì ”—«”—Ì ---
char header_buffer[100];
char content_buffer[100];
char ip_address_buffer[16];
char phone_number[16];
char response_buffer[256]; // «›“«Ì‘ ”«Ì“ »«›— »—«Ì œ—Ì«›  Å«”ŒùÂ«Ì HTTP

// ---  ⁄—Ì› ÅÌ‰ùÂ«Ì „Ê Ê— ---
#define MOTOR_DDR DDRE
#define MOTOR_PORT PORTE
#define MOTOR_PIN_1 2
#define MOTOR_PIN_2 3
#define MOTOR_PIN_3 4

// ---  ⁄—Ì› ÅÌ‰ùÂ«Ì òÌùÅœ ---
#define KEYPAD_PORT PORTC
#define KEYPAD_DDR DDRC
#define KEYPAD_PIN PINC
#define COL1_PIN 0
#define COL2_PIN 1
#define COL3_PIN 2
#define ROW1_PIN 7
#define ROW2_PIN 5
#define ROW3_PIN 6
#define ROW4_PIN 4

#include "bitmaps.h"


//__flash unsigned char payamak[1024] = {
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x00, 0x00,
//    0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
//    0x80, 0x00, 0x00, 0x00, 0x08, 0x98, 0x80, 0x00, 0x00, 0x0E, 0x1A, 0x32, 0x73, 0xC3, 0x81, 0x01,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00,
//    0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
//    0xE0, 0xC0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x1A, 0x32, 0xE3, 0x81, 0x01, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0xC0, 0x60, 0x60, 0xE0, 0xC0, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x8C, 0xCC, 0x4C, 0x47,
//    0xC7, 0x0C, 0x0C, 0x0C, 0x0C, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x03, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x3E, 0x6F, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x40, 0x60, 0x3F, 0x00, 0x00,
//    0x00, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x07, 0x0E, 0x0C, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x0C,
//    0x0C, 0x03, 0x00, 0x80, 0xC0, 0xE1, 0x3F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x07, 0x04, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x07, 0x06, 0x0C, 0x0C, 0x0C,
//    0x0C, 0x06, 0x07, 0x04, 0x0C, 0x0C, 0x0C, 0x07, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x0C, 0x0C, 0xCC,
//    0xCC, 0x8C, 0xC7, 0x4E, 0x0C, 0xCC, 0xCC, 0x8C, 0xCC, 0x8D, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//};


void draw_bitmap(uint8_t x, uint8_t y, __flash unsigned char* bmp, uint8_t width, uint8_t height)
{
    uint16_t byte_index;
    uint8_t page;
    uint8_t col;
    uint8_t bit_pos;
    uint8_t data;
    uint8_t pages;

    byte_index = 0;
    pages = height / 8;

    for (page = 0; page < pages; page++) {
        for (col = 0; col < width; col++) {
            data = read_flash_byte(&bmp[byte_index++]);
            for (bit_pos = 0; bit_pos < 8; bit_pos++) {
                if (data & (1 << bit_pos)) {
                    glcd_pixel(x + col, y + (page * 8) + bit_pos, 1);
                }
            }
        }
    }
}





//  «»⁄ «—”«· œ” Ê— AT »Â „«éÊ·
void send_at_command(char *command)
{
    printf("%s\r\n", command);
}

unsigned char read_serial_response(char* buffer, int buffer_size, int timeout_ms, char* expected_response) {
    int i = 0;
    unsigned int timeout_counter = 0;
    char c;

    // Clear the buffer at the start
    memset(buffer, 0, buffer_size);

    // Loop until the timeout period is reached
    while (timeout_counter < timeout_ms) {
        // This is the correct way to check if a character has been received on USART0
        if (UCSR0A & (1 << RXC0)) {
            c = getchar(); // Read the character from the buffer
            if (i < (buffer_size - 1)) {
                buffer[i++] = c; // Add it to our response buffer
            }
            // Optional: You can reset the timeout counter each time a character is received
            // to wait for the *entire* message to finish. For simplicity, we'll use a fixed timeout.
        } else {
            // If no character is waiting, wait 1ms and increment the counter
            delay_ms(1);
            timeout_counter++;
        }
    }

    // After the loop finishes, check if the expected text exists in the buffer
    if (strstr(buffer, expected_response) != NULL) {
        return 1; // Success!
    }

    return 0; // Failed to find the response
}


void usart_puts(const char* str)
{
    while (*str)
    {
        putchar(*str++); // 'usart_putchar' is your function to send a single byte
    }
}


unsigned char check_gprs_status(void) {
    char response[100];

    send_at_command("AT+SAPBR=2,1");
    if (read_serial_response(response, sizeof(response), 200, "+SAPBR:")) {
        if (strstr(response, "+SAPBR: 1,1,") != NULL) {
            return 1; // Already connected
        }
    }
    return 0; // Not connected
}


unsigned char init_sms(void)
{
    glcd_clear();
    glcd_outtextxy(0, 0, "Setting SMS Mode...");
    send_at_command("AT+CMGF=1");
    delay_ms(100);

    send_at_command("AT+CNMI=2,2,0,0,0");
    delay_ms(100);

    send_at_command("AT+CMGDA=\"DEL ALL\"");
    delay_ms(200);


    // «ÿ„Ì‰«‰ «“ ›⁄«· »Êœ‰ ò«„· „«éÊ· Ê €Ì—›⁄«· »Êœ‰ sleep
    send_at_command("AT+CFUN=1");    // ›⁄«·ù”«“Ì ò«„· „«éÊ·
    delay_ms(100);
    send_at_command("AT+CSCLK=0");   // €Ì—›⁄«·ù”«“Ì Õ«·  sleep
    delay_ms(100);

    glcd_outtextxy(0, 10, "SMS Ready.");
    delay_ms(200);
    return 1;
}


unsigned char init_GPRS(void)
{
    char at_command[50];
    char response[100]; // Local buffer for the response

    glcd_clear();
    glcd_outtextxy(0, 0, "Connecting to GPRS...");

    send_at_command("AT+SAPBR=3,1,\"Contype\",\"GPRS\"");
    delay_ms(300);

    sprintf(at_command, "AT+SAPBR=3,1,\"APN\",\"%s\"", APN);
    send_at_command(at_command);
    delay_ms(300);

    send_at_command("AT+SAPBR=1,1");
    delay_ms(300);

    glcd_clear();
    glcd_outtextxy(0, 0, "Fetching IP...");
    send_at_command("AT+SAPBR=2,1"); // Request IP
    // delay_ms(5000);
    
    // Attempt to read the response for 5 seconds, looking for "+SAPBR:"
    // FIX: Added the 4th argument, "+SAPBR:", to the function call.
    if (read_serial_response(response, sizeof(response), 200, "+SAPBR:")) {
        glcd_outtextxy(0, 10, "Resp:");
        glcd_outtextxy(0, 20, response); // Display the received response for debugging
        delay_ms(200);

        // Check if the response contains the IP address part
        if (strstr(response, "+SAPBR: 1,1,") != NULL) {
            char* token = strtok(response, "\"");
            token = strtok(NULL, "\"");

            if (token) {
                strcpy(ip_address_buffer, token);
                return 1; // Success
            }
        }
    }

    // If we reach here, it means getting the IP address failed
    return 0; // Failure
}


unsigned char send_json_post(const char* base_url, const char* phone_number) {
    char cmd[256];
    char response[256];
    char full_url[256];    
    char* action_ptr;
    int method = 0, status_code = 0, data_len = 0;

    if (!check_gprs_status()) {
        if (!init_GPRS()) {
            glcd_clear();
            glcd_outtextxy(0, 0, "GPRS Failed!");
            delay_ms(1000);
            return 0;
        }
    }

 
    glcd_clear();
    glcd_outtextxy(0,10,phone_number);
    glcd_outtextxy(0,20,"lev 0");
   
    // 1. Initialize HTTP service
    send_at_command("AT+HTTPINIT");
    if (!read_serial_response(response, sizeof(response), 100, "OK")) return 0;

//    glcd_clear();
//    glcd_outtextxy(0,10,phone_number);
    glcd_outtextxy(0,20,"lev 1");

    // 2. Set CID to bearer profile 1
    send_at_command("AT+HTTPPARA=\"CID\",1");
    if (!read_serial_response(response, sizeof(response), 100, "OK")) return 0;

    glcd_outtextxy(0,20,"lev 2");

    // 3. Build the full URL with query parameter
    sprintf(full_url, "%s?phone_number=%s", base_url, phone_number);

    // 4. Set the target URL
    sprintf(cmd, "AT+HTTPPARA=\"URL\",\"%s\"", full_url);
    send_at_command(cmd);
    if (!read_serial_response(response, sizeof(response), 100, "OK")) return 0;

    glcd_outtextxy(0,20,"lev 3");

    // 5. Start POST action
    send_at_command("AT+HTTPACTION=1");
    if (!read_serial_response(response, sizeof(response), HTTP_TIMEOUT_MS, "+HTTPACTION:")) {
        glcd_clear();
        glcd_outtextxy(0,0,"No Action Resp");
        delay_ms(100);
        return 0;
    }

    glcd_outtextxy(0,20,"lev 4");

    // 6. Parse status code from response

    action_ptr = strstr(response, "+HTTPACTION:");
    if (action_ptr == NULL || sscanf(action_ptr, "+HTTPACTION: %d,%d,%d", &method, &status_code, &data_len) != 3) {
        glcd_clear();
        glcd_outtextxy(0,0,"Parse Err");
        glcd_outtextxy(0,10,response);  // ‰„«Ì‘ „Õ Ê«Ì response ò«„· »—«Ì œÌ»«ê
        delay_ms(500);
        return 0;
    }
    
    glcd_outtextxy(0,20,"lev 5");
    //delay_ms(200);
    // 7. Show response based on status
    glcd_clear();
    glcd_outtextxy(0,0,"HTTP Status:");
    if (status_code == 200) {
        glcd_outtextxy(0,10,"OK");
    } else {
        glcd_outtextxy(0,10,"Not OK");
    }             
    //delay_ms(200);
    glcd_outtextxy(0,20,"lev 6");

    // 8. Read server response if needed
    send_at_command("AT+HTTPREAD");
    read_serial_response(response, sizeof(response), 100, "OK");

    glcd_outtextxy(0,20,"lev 7");

    // 9. Terminate HTTP service
    send_at_command("AT+HTTPTERM");
    read_serial_response(response, sizeof(response), 100, "OK");
                                                                   
    glcd_outtextxy(0,20,"lev 8");
    return (status_code == 200) ? 1 : 0;
}


///////////////////////////////////////////////////////////////////////////////////////////





//unsigned char init_GPRS(void)
//{
//    char at_command[50];
//    char response[100]; // Local buffer for the response
//
//    glcd_clear();
//    glcd_outtextxy(0, 0, "Connecting to GPRS...");
//
//    send_at_command("AT+SAPBR=3,1,\"Contype\",\"GPRS\"");
//    delay_ms(300);
//
//    sprintf(at_command, "AT+SAPBR=3,1,\"APN\",\"%s\"", APN);
//    send_at_command(at_command);
//    delay_ms(300);
//
//    send_at_command("AT+SAPBR=1,1");
//    delay_ms(300);
//
//    glcd_clear();
//    glcd_outtextxy(0, 0, "Fetching IP...");
//    send_at_command("AT+SAPBR=2,1"); // Request IP
//    // delay_ms(5000);
//    
//    // Attempt to read the response for 5 seconds, looking for "+SAPBR:"
//    // FIX: Added the 4th argument, "+SAPBR:", to the function call.
//    if (read_serial_response(response, sizeof(response), 200, "+SAPBR:")) {
//        glcd_outtextxy(0, 10, "Resp:");
//        glcd_outtextxy(0, 20, response); // Display the received response for debugging
//        delay_ms(200);
//
//        // Check if the response contains the IP address part
//        if (strstr(response, "+SAPBR: 1,1,") != NULL) {
//            char* token = strtok(response, "\"");
//            token = strtok(NULL, "\"");
//
//            if (token) {
//                strcpy(ip_address_buffer, token);
//                return 1; // Success
//            }
//        }
//    }
//
//    // If we reach here, it means getting the IP address failed
//    return 0; // Failure
//}
 



char get_key(void)
{
    unsigned char row, col;
    const unsigned char column_pins[3] = {COL1_PIN, COL2_PIN, COL3_PIN};
    const unsigned char row_pins[4] = {ROW1_PIN, ROW2_PIN, ROW3_PIN, ROW4_PIN};

    const char key_map[4][3] = {
        {'1', '2', '3'},
        {'4', '5', '6'},
        {'7', '8', '9'},
        {'*', '0', '#'}
    };

    for (col = 0; col < 3; col++)
    {
        KEYPAD_PORT |= (1 << COL1_PIN) | (1 << COL2_PIN) | (1 << COL3_PIN);
        KEYPAD_PORT &= ~(1 << column_pins[col]);

        for (row = 0; row < 4; row++)
        {
            if (!(KEYPAD_PIN & (1 << row_pins[row])))
            {
                delay_ms(10);

                if (!(KEYPAD_PIN & (1 << row_pins[row])))
                {
                    while (!(KEYPAD_PIN & (1 << row_pins[row])));
                    return key_map[row][col];
                }
            }
        }
    }

    // C?? ??? ???I? ?O?I? ?OI? E?I? ??IC? ??? (NULL) ?C E???IC?
    return 0;
}




void activate_motor(int product_id)
{
    unsigned char motor_pin;
    char motor_msg[20];

    switch (product_id)
    {
        case 1: motor_pin = MOTOR_PIN_1; break;
        case 2: motor_pin = MOTOR_PIN_2; break;
        case 3: motor_pin = MOTOR_PIN_3; break;
        default: return;
    }

    sprintf(motor_msg, "MOTOR %d ON!", product_id);
    glcd_clear();
    glcd_outtextxy(10, 20, motor_msg);
    MOTOR_PORT |= (1 << motor_pin);
    delay_ms(500);
    MOTOR_PORT &= ~(1 << motor_pin);

    sprintf(motor_msg, "MOTOR %d OFF!", product_id);
    glcd_outtextxy(10, 40, motor_msg);
    delay_ms(200);
}

///////////////////////////////////////////////////////////////////////////////////

void main(void)
{
    const char* server_url = "http://193.5.44.191/home/post/";
    const char* my_phone    = "+989152608582";
    
    GLCDINIT_t glcd_init_data;

    // --- C?? EIO ??IC?I?? C???? ???E??C ? USART C?E ?? C? ?I I?IEC? ??? OI? ---
    // --- ? ???? C?E. ??C?? E? EU??? A? ???E.                             ---
    DDRA=(0<<DDA7) | (0<<DDA6) | (0<<DDA5) | (0<<DDA4) | (0<<DDA3) | (0<<DDA2) | (0<<DDA1) | (0<<DDA0);
    PORTA=(0<<PORTA7) | (0<<PORTA6) | (0<<PORTA5) | (0<<PORTA4) | (0<<PORTA3) | (0<<PORTA2) | (0<<PORTA1) | (0<<PORTA0);
    DDRB=(0<<DDB7) | (0<<DDB6) | (0<<DDB5) | (0<<DDB4) | (0<<DDB3) | (0<<DDB2) | (0<<DDB1) | (0<<DDB0);
    PORTB=(1<<PORTB7) | (1<<PORTB6) | (1<<PORTB5) | (1<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0);
    DDRC=(0<<DDC7) | (0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (1<<DDC2) | (1<<DDC1) | (1<<DDC0);
    PORTC=(1<<PORTC7) | (1<<PORTC6) | (1<<PORTC5) | (1<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORTC0);
    DDRE=(0<<DDE7) | (0<<DDE6) | (1<<DDE5) | (1<<DDE4) | (1<<DDE3) | (1<<DDE2) | (0<<DDE1) | (0<<DDE0);
    PORTE=(0<<PORTE7) | (0<<PORTE6) | (0<<PORTE5) | (0<<PORTE4) | (0<<PORTE3) | (0<<PORTE2) | (0<<PORTE1) | (0<<PORTE0);
    DDRF=(0<<DDF7) | (0<<DDF6) | (0<<DDF5) | (0<<DDF4) | (0<<DDF3) | (0<<DDF2) | (0<<DDF1) | (0<<DDF0);
    PORTF=(0<<PORTF7) | (0<<PORTF6) | (0<<PORTF5) | (0<<PORTF4) | (0<<PORTF3) | (0<<PORTF2) | (0<<PORTF1) | (0<<PORTF0);
    UCSR0A=(0<<RXC0) | (0<<TXC0) | (0<<UDRE0) | (0<<FE0) | (0<<DOR0) | (0<<UPE0) | (0<<U2X0) | (0<<MPCM0);
    UCSR0B=(0<<RXCIE0) | (0<<TXCIE0) | (0<<UDRIE0) | (1<<RXEN0) | (1<<TXEN0) | (0<<UCSZ02) | (0<<RXB80) | (0<<TXB80);
    UCSR0C=(0<<UMSEL0) | (0<<UPM01) | (0<<UPM00) | (0<<USBS0) | (1<<UCSZ01) | (1<<UCSZ00) | (0<<UCPOL0);
    UBRR0H=0x00;
    UBRR0L=0x33; // 9600 Baud Rate for 8MHz clock
    MCUCSR = (1 << JTD);
    MCUCSR = (1 << JTD);
    glcd_init_data.font=font5x7;
    glcd_init_data.readxmem=NULL;
    glcd_init_data.writexmem=NULL;
    glcd_init(&glcd_init_data);
    glcd_setfont(font5x7);
    // --- ?C?C? EIO ??IC?I?? C???? ---

    glcd_clear();
    glcd_outtextxy(0, 0, "Module Init...");
    delay_ms(3000);

    send_at_command("ATE0");
    delay_ms(300);
    send_at_command("AT");
    delay_ms(300);

    if (!init_sms()) { glcd_outtextxy(0, 10, "SMS Init Failed!"); while(1); }
    if (!init_GPRS()) { glcd_outtextxy(0, 10, "GPRS Init Failed!"); while(1); }

    glcd_clear();
    glcd_outtextxy(0, 0, "System Ready.");
    glcd_outtextxy(0, 10, "Waiting for SMS...");


//    glcd_clear();
//    glcd_outtextxy(0,0,"Sending POST...");
//    if (send_json_post(server_url, my_phone)) {
//        glcd_outtextxy(0,10,"POST OK");
//    } else {
//        glcd_outtextxy(0,10,"POST Fail");
//    }


    glcd_clear();
    draw_bitmap(0, 0, payamak, 128, 64);
    delay_ms(200);

    while (1)
    {
//        char sms_char;
//        char key_pressed;
//        char display_buffer[2] = {0};
//        int product_id = 0;
//        int timeout_counter = 0;
//        char* token;
//
//        char content_buffer[32];
//        memset(header_buffer, 0, sizeof(header_buffer));
//        memset(content_buffer, 0, sizeof(content_buffer));
//
//        if (gets(header_buffer, sizeof(header_buffer)))
//        {
//            if (strstr(header_buffer, "+CMT:") != NULL)
//            {
//                // ?? ›Ê—« „ ‰ ÅÌ«„ò —Ê »ŒÊ‰ Ê ‰êÂ œ«—
//                if (!gets(content_buffer, sizeof(content_buffer))) {
//                    glcd_clear();
//                    glcd_outtextxy(0, 0, "Failed to read msg");
//                    delay_ms(1000);
//                    continue;
//                }
//
//                // ?? ‘„«—Â  ·›‰ —Ê »êÌ—
//                token = strtok(header_buffer, "\"");
//                if (token != NULL) token = strtok(NULL, "\"");
//                if (token != NULL)
//                {
//                    strcpy(phone_number, token);
//
//                    // ?? Õ«·« „ÃÊ“ —Ê »——”Ì ò‰
//                    if (send_json_post(server_url, phone_number))
//                    {
//                        glcd_clear();
//                        glcd_outtextxy(0, 5, "step 1");
//                        delay_ms(200);
//
//                        sms_char = content_buffer[0];  // „À·« '1'
//
//                        glcd_outtextxy(0, 5, "step 2");
//                        delay_ms(200);
//
//                        if (sms_char == '1' || sms_char == '2' || sms_char == '3')
//                        {
//                            glcd_clear();
//                            glcd_outtextxy(0, 5, "SMS Code:");
//                            display_buffer[0] = sms_char;
//                            glcd_outtextxy(70, 5, display_buffer);
//                            glcd_outtextxy(0, 25, "Enter code on keypad:");
//
//                            key_pressed = 0;
//                            for (timeout_counter = 0; timeout_counter < 200; timeout_counter++)
//                            {
//                                key_pressed = get_key();
//                                if (key_pressed != 0) break;
//                                delay_ms(10);
//                            }
//
//                            if (key_pressed == 0)
//                            {
//                                glcd_clear();
//                                glcd_outtextxy(10, 25, "Timeout! Try again.");
//                                delay_ms(200);
//                            }
//                            else
//                            {
//                                glcd_outtextxy(0, 45, "You pressed:");
//                                display_buffer[0] = key_pressed;
//                                glcd_outtextxy(90, 45, display_buffer);
//                                delay_ms(200);
//
//                                if (key_pressed == sms_char)
//                                {
//                                    glcd_clear();
//                                    glcd_outtextxy(10, 25, "Code is CORRECT!");
//                                    delay_ms(300);
//                                    product_id = sms_char - '0';
//                                    activate_motor(product_id);
//                                }
//                                else
//                                {
//                                    glcd_clear();
//                                    glcd_outtextxy(5, 25, "Error in entry!");
//                                    delay_ms(300);
//                                }
//                            }
//                        }
//                        else
//                        {
//                            glcd_clear();
//                            glcd_outtextxy(5, 25, "Invalid SMS Code!");
//                            delay_ms(300);
//                        }
//                    }
//                    else
//                    {
//                        glcd_clear();
//                        glcd_outtextxy(0, 25, "You are not authorized!");
//                        delay_ms(300);
//                    }
//                }
//
//                // »«“ê‘  »Â Ê÷⁄Ì  ¬„«œÂù»Âùò«—
//                glcd_clear();
//                glcd_outtextxy(0, 0, "System Ready.");
//                glcd_outtextxy(0, 10, "Waiting for SMS...");
//            }
//        }
    }

}